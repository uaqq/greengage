-- This test triggers failover of content 1 and checks
-- the correct tracking state behaviour after recovery
!\retcode gpconfig -c shared_preload_libraries -v "$(psql -At -c "SELECT array_to_string(array_append(string_to_array(current_setting('shared_preload_libraries'), ','), 'gg_tables_tracking'), ',')" postgres)";
(exited with code 0)
-- Allow extra time for mirror promotion to complete recovery
!\retcode gpconfig -c gp_fts_probe_timeout -v 5 --masteronly;
(exited with code 0)
!\retcode gpconfig -c gp_fts_probe_retries -v 2 --masteronly;
(exited with code 0)
!\retcode gpstop -raq -M fast;
(exited with code 0)
!\retcode gpconfig -c gg_tables_tracking.tracking_worker_naptime_sec -v '5';
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

CREATE EXTENSION IF NOT EXISTS gg_tables_tracking;
CREATE EXTENSION

!\retcode gpconfig -c gg_tables_tracking.tracking_worker_naptime_sec -v '5';
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

SELECT gg_tables_tracking.wait_for_worker_initialize();
 wait_for_worker_initialize 
----------------------------
 t                          
(1 row)
SELECT gg_tables_tracking.tracking_register_db();
 tracking_register_db 
----------------------
 t                    
(1 row)
SELECT gg_tables_tracking.tracking_trigger_initial_snapshot();
 tracking_trigger_initial_snapshot 
-----------------------------------
 t                                 
(1 row)

-- Test track acquisition returns the same count of tuples as pg_class has with
-- default filter options.
WITH segment_counts AS ( SELECT tt.segid, COUNT(*) AS cnt FROM gg_tables_tracking.tables_track tt GROUP BY tt.segid ), pg_class_count AS ( SELECT COUNT(*) AS cnt FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid WHERE nspname = ANY (string_to_array(current_setting('gg_tables_tracking.tracking_schemas'), ',')) AND c.relkind = ANY (string_to_array(current_setting('gg_tables_tracking.tracking_relkinds'), ',')) ) SELECT bool_and(sc.cnt = pc.cnt) FROM segment_counts sc, pg_class_count pc;
 bool_and 
----------
 t        
(1 row)

-- Helper functions
CREATE OR REPLACE FUNCTION tracking_is_segment_initialized_master() /* in func */ RETURNS TABLE(segindex INT, is_initialized BOOL) AS $$ /* in func */ SELECT segindex, is_initialized /* in func */ FROM gg_tables_tracking.tracking_is_segment_initialized(); /* in func */ $$ LANGUAGE SQL EXECUTE ON MASTER;
CREATE FUNCTION

CREATE OR REPLACE FUNCTION tracking_is_segment_initialized_segments() /* in func */ RETURNS TABLE(segindex INT, is_initialized BOOL) AS $$ /* in func */ SELECT segindex, is_initialized /* in func */ FROM gg_tables_tracking.tracking_is_segment_initialized(); /* in func */ $$ LANGUAGE SQL EXECUTE ON ALL SEGMENTS;
CREATE FUNCTION

-- no segment down.
SELECT count(*) FROM gp_segment_configuration WHERE status = 'd';
 count 
-------
 0     
(1 row)

SELECT pg_ctl((select datadir FROM gp_segment_configuration c WHERE c.role='p' AND c.content=1), 'stop');
 pg_ctl 
--------
 OK     
(1 row)

SELECT wait_until_segments_are_down(1);
 wait_until_segments_are_down 
------------------------------
 t                            
(1 row)

1: SELECT gg_tables_tracking.wait_for_worker_initialize();
 wait_for_worker_initialize 
----------------------------
 t                          
(1 row)
1q: ... <quitting>
SELECT * FROM tracking_is_segment_initialized_master() UNION ALL SELECT * FROM tracking_is_segment_initialized_segments();
 segindex | is_initialized 
----------+----------------
 -1       | t              
 0        | t              
 1        | t              
 2        | t              
(4 rows)

-- Track acquisition should return full snapshot from promoted mirror since
-- initial snapshot is activated on recovery by default.
WITH segment_counts AS ( SELECT COUNT(*) AS cnt FROM gg_tables_tracking.tables_track tt WHERE tt.segid = 1 GROUP BY tt.segid ), pg_class_count AS ( SELECT COUNT(*) AS cnt FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid WHERE nspname = ANY (string_to_array(current_setting('gg_tables_tracking.tracking_schemas'), ',')) AND c.relkind = ANY (string_to_array(current_setting('gg_tables_tracking.tracking_relkinds'), ',')) ) SELECT bool_and(sc.cnt = pc.cnt) FROM segment_counts sc, pg_class_count pc;
 bool_and 
----------
 t        
(1 row)

-- fully recover the failed primary as new mirror
!\retcode gprecoverseg -aF --no-progress;
(exited with code 0)

-- loop while segments come in sync
SELECT wait_until_all_segments_synchronized();
 wait_until_all_segments_synchronized 
--------------------------------------
 OK                                   
(1 row)

!\retcode gprecoverseg -ar;
(exited with code 0)

-- loop while segments come in sync
SELECT wait_until_all_segments_synchronized();
 wait_until_all_segments_synchronized 
--------------------------------------
 OK                                   
(1 row)

-- verify no segment is down after recovery
SELECT count(*) FROM gp_segment_configuration WHERE status = 'd';
 count 
-------
 0     
(1 row)

SELECT gg_tables_tracking.wait_for_worker_initialize();
 wait_for_worker_initialize 
----------------------------
 t                          
(1 row)

-- Track should be returned only from recovered segment since
-- initial snapshot is activated on recovery by default.
WITH segment_counts AS ( SELECT COUNT(*) AS cnt FROM gg_tables_tracking.tables_track tt GROUP BY tt.segid ), pg_class_count AS ( SELECT COUNT(*) AS cnt FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid WHERE nspname = ANY (string_to_array(current_setting('gg_tables_tracking.tracking_schemas'), ',')) AND c.relkind = ANY (string_to_array(current_setting('gg_tables_tracking.tracking_relkinds'), ',')) ) SELECT bool_and(sc.cnt = pc.cnt) FROM segment_counts sc, pg_class_count pc;
 bool_and 
----------
 t        
(1 row)

SELECT gg_tables_tracking.tracking_unregister_db();
 tracking_unregister_db 
------------------------
 t                      
(1 row)

!\retcode gpconfig -r gp_fts_probe_retries --masteronly;
(exited with code 0)
!\retcode gpconfig -r gp_gang_creation_retry_count --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpconfig -r gp_gang_creation_retry_timer --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)
