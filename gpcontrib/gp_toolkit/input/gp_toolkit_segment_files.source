-- start_ignore
DROP TABLESPACE ts_test;
DROP ROLE user_test;
-- end_ignore

-- Test with different table types

\! rm -rf @testtablespace@ && mkdir @testtablespace@ && mkdir @testtablespace@/seg0_tablespace;
CREATE TABLESPACE ts_test LOCATION '@testtablespace@'
WITH (content0='@testtablespace@/seg0_tablespace');

CREATE TEMP VIEW _show_files_current AS
SELECT regexp_replace(table_name, '\d+', 'tbloid') AS table_name,
       table_schema, content, relamname, relispartition
FROM gp_toolkit.gp_db_files_current
WHERE table_tablespace = 'ts_test' AND table_name <> '';

-- empty tablespace
SELECT * FROM _show_files_current;

-- heap
CREATE TABLE heap(id int) TABLESPACE ts_test DISTRIBUTED BY(id);
INSERT INTO heap SELECT generate_series(1, 100);
SELECT * FROM _show_files_current;
DROP TABLE heap;

-- heap with custom schema
CREATE SCHEMA test_schema;
CREATE TABLE test_schema.heap(id int) TABLESPACE ts_test DISTRIBUTED BY(id);
INSERT INTO test_schema.heap SELECT generate_series(1, 100);
SELECT * FROM _show_files_current;
DROP TABLE test_schema.heap;

-- with toast
CREATE TABLE heap_toast(id int, data text) TABLESPACE ts_test DISTRIBUTED BY(id);
INSERT INTO heap_toast SELECT i, i::text FROM generate_series(1, 100) AS i;
SELECT * FROM _show_files_current;
DROP TABLE heap_toast;

-- ao
CREATE TABLE ao (id int) WITH (APPENDONLY = true) TABLESPACE ts_test DISTRIBUTED BY(id);
INSERT INTO ao SELECT generate_series(1, 100);
SELECT * FROM _show_files_current;
DROP TABLE ao;

-- co
CREATE TABLE co (id int) WITH (APPENDONLY = true, ORIENTATION = column) TABLESPACE ts_test DISTRIBUTED BY(id);
INSERT INTO co SELECT generate_series(1, 100);
SELECT * FROM _show_files_current;
DROP TABLE co;

-- temp
CREATE TEMP TABLE tmp(id int) TABLESPACE ts_test DISTRIBUTED BY(id);
INSERT INTO tmp SELECT generate_series(1, 100);
SELECT * FROM _show_files_current;
DROP TABLE tmp;

-- materialized view
CREATE MATERIALIZED VIEW mat_view TABLESPACE ts_test AS
(SELECT generate_series(1, 100) AS id) DISTRIBUTED BY(id);
SELECT * FROM _show_files_current;
DROP MATERIALIZED VIEW mat_view;

-- partitioned table
CREATE TABLE ptable (id int, a int, b int)
TABLESPACE ts_test
DISTRIBUTED BY (id)
PARTITION BY RANGE (a)
    SUBPARTITION BY RANGE (b)
        SUBPARTITION TEMPLATE (START (1) END (3) EVERY (1))
    (START (1) END (3) EVERY (1));
INSERT INTO ptable
    SELECT i+1, mod(i/4,2)+1, mod(i/2,2)+1
    FROM generate_series(0,100) AS i;
SELECT * FROM _show_files_current;
DROP TABLE ptable;

-- Test paths

-- clean tablespace dir before unmapped files test
DROP TABLESPACE ts_test;
\! rm -rf @testtablespace@ && mkdir @testtablespace@
CREATE TABLESPACE ts_test LOCATION '@testtablespace@';

CREATE TABLE t(id int) TABLESPACE ts_test DISTRIBUTED BY (id);
INSERT INTO t SELECT generate_series(1,100);

CREATE TABLE t_default(id int) DISTRIBUTED BY (id);
INSERT INTO t_default SELECT generate_series(1,100);

-- tablespace location
SELECT
  f.table_name,
  f.table_schema,
  f.content,
  f.table_tablespace,
  replace(
    replace(f.tablespace_location, gpconf.datadir, '<SEGMENT_BASE_DIR>'),
    '@testtablespace@', '<TEST_TABLESPACE_LOCATION_DIR>'
  ) AS tablespace_location
FROM gp_toolkit.gp_db_files_current AS f
JOIN gp_segment_configuration AS gpconf
  ON gpconf.content = f.content
 AND gpconf.preferred_role = (f.segment_preferred_role)::char(1)
WHERE f.table_name IN ('t_default', 'gp_segment_configuration', 't');

-- Check that returned files are exist
CREATE view expected_files AS SELECT table_name, content, file
FROM gp_toolkit.gp_db_files_current
WHERE table_name IN ('t_default', 'gp_segment_configuration', 't');

CREATE EXTERNAL WEB TABLE file_list (line text)
EXECUTE 'find -L $GP_SEG_DATADIR -type f'
FORMAT 'TEXT';

WITH fl AS (SELECT * FROM file_list)
SELECT
    e.table_name,
    e.content,
    CASE
        WHEN fl.line IS NOT NULL THEN 'file exists'
        ELSE ('file does not exist: ' || e.file)
    END AS conclusion
FROM expected_files AS e
LEFT JOIN fl ON e.file = fl.line;

DROP VIEW expected_files;
DROP EXTERNAL WEB TABLE file_list;

-- unmapped files (produce unmapped files and check that they are listed)
\cd @testtablespace@
select dbid from gp_segment_configuration where content = 0 and role = 'p' \gset
\cd :dbid
select get_tablespace_version_directory_name() as version_dir \gset
\cd :version_dir
select oid from pg_database where datname = current_database() \gset
\cd :oid
\! touch 4000000000 4000000000.42
\cd @testtablespace@
select dbid from gp_segment_configuration where content =  1 and role = 'p' \gset
\cd :dbid
select get_tablespace_version_directory_name() as version_dir \gset
\cd :version_dir
select oid from pg_database where datname = current_database() \gset
\cd :oid
\! touch 4000000001 4000000001.42

SELECT content, regexp_replace(file, '^.*/', 'XXX/') AS short_path
FROM gp_toolkit.gp_db_files_current_unmapped
WHERE table_tablespace = 'ts_test';

DROP TABLE t, t_default;
\! rm -rf @testtablespace@
DROP TABLESPACE ts_test;

-- Test provolatile and rows properties

SELECT proname, provolatile, prorows
    FROM pg_proc
    WHERE oid IN (
        'gp_toolkit.__gp_get_relfilenodes(oid)'::regprocedure,
        'gp_toolkit.__gp_tablespace_location(oid)'::regprocedure,
        'gp_toolkit.gp_get_relfilenodes(oid)'::regprocedure
    );

-- Test access (should be revoked for all except superuser)

CREATE ROLE user_test RESOURCE QUEUE pg_default;
GRANT CREATE, USAGE ON SCHEMA public TO user_test;
ALTER USER user_test SET search_path TO public;
SET ROLE user_test;

SELECT gp_toolkit.__gp_get_relfilenodes(oid)
FROM pg_tablespace WHERE spcname = 'pg_global';

SELECT gp_toolkit.__gp_tablespace_location(oid)
FROM pg_tablespace WHERE spcname = 'pg_global';

SELECT gp_toolkit.gp_get_relfilenodes(oid)
FROM pg_tablespace WHERE spcname = 'pg_global';

table gp_toolkit.gp_db_segment_files;

table gp_toolkit.gp_db_files_current;

table gp_toolkit.gp_db_files_current_unmapped;

RESET ROLE;
REVOKE CREATE, USAGE ON SCHEMA public FROM user_test;
DROP ROLE user_test;

-- Test support for squelching in SRF

-- The SRF should close the directory even if iteration stops early
-- (e.g., when a LIMIT is reached). If it does not, a warning will be emitted.
SELECT (r).segindex, (r).tablespace_oid
FROM (SELECT gp_toolkit.__gp_get_relfilenodes(1664) AS r) AS s
LIMIT 1;

