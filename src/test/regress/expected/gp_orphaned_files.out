-- start_ignore
-- end_ignore
-- start_matchsubs
-- m/ERROR:  Error on receive from seg\d+ slice\d+ \d+.\d+.\d+.\d+:\d+ pid=\d+: server closed the connection unexpectedly/
-- s/ERROR:  Error on receive from seg\d+ slice\d+ \d+.\d+.\d+.\d+:\d+ pid=\d+: server closed the connection unexpectedly/ERROR:  Error on receive from segX sliceX X.X.X.X:X pid=X: server closed the connection unexpectedly/
-- end_matchsubs
-- Test case 1
-- Check that orphaned files are not left on the coordinator and the standby
-- when the files are created after checkpoint
-- Create tables of different access methods and return command to check their
-- files existence on the coordinator and the standby
create or replace function createTables() returns text as
$$
declare
  cmd text;
begin
  create table t_orphaned_h(i int)
  distributed by (i);

  create table t_orphaned_r(i int)
  with (appendonly=true, orientation=row)
  distributed by (i);
  -- Create index to create block directory table
  create index t_orphaned_r_i on t_orphaned_r(i);

  create table t_orphaned_c(i int)
  with (appendonly=true, orientation=column)
  distributed by (i);
  -- Create index to create block directory table
  create index t_orphaned_c_i on t_orphaned_c(i);

  -- Ensure that the mirrors have applied the filesystem changes
  perform force_mirrors_to_catch_up();

  -- The command do not output PGDATA directories to make it possible to run
  -- the test without docker
  select '\! ' ||
         string_agg('cd ' || datadir || '&&' || lswc, ';' order by datadir)
  into cmd
  from (
    select 'ls ' || string_agg(pg_relation_filepath(a.unnest), ' ')
                 || ' 2>/dev/null | wc -l' lswc
    from (
      select unnest(array['t_orphaned_h'::regclass,
                          't_orphaned_r'::regclass, 't_orphaned_r_i'::regclass,
                          't_orphaned_c'::regclass, 't_orphaned_c_i'::regclass])
      union all
      select unnest(array[segrelid, blkdirrelid, visimaprelid])
        from pg_catalog.pg_appendonly
        where relid in ('t_orphaned_r'::regclass, 't_orphaned_c'::regclass)
      union all
      select distinct objid from pg_depend where
        classid = 'pg_class'::regclass and deptype = 'a'
        and refobjid in (
          select unnest(array[blkdirrelid,visimaprelid])
            from pg_catalog.pg_appendonly
            where relid in ('t_orphaned_r'::regclass, 't_orphaned_c'::regclass))
    ) a
  ) f,
  (select datadir from gp_segment_configuration where content = -1) d;

  return cmd;
end
$$ language plpgsql;
checkpoint;
-- Skip checkpoints on the coordinator
select gp_inject_fault_infinite('checkpoint', 'skip', dbid)
  from gp_segment_configuration
 where role = 'p' and content = -1;
 gp_inject_fault_infinite 
--------------------------
 Success:
(1 row)

-- Create tables in subtransactions
begin;
create table t_top(i int) distributed by (i);
savepoint sp1;
create table t_sub1(i int) distributed by (i);
savepoint sp2;
create table t_sub2(i int) distributed by (i);
commit;
-- Start transaction and create tables in it
begin;
select createTables() check_files
\gset
 
-- Make sure that the tables files exist on the coordinator and the standby
:check_files
15
15
-- Get segfault on the coordinator and reconnect after its restart
select gp_inject_fault('exec_simple_query_start', 'segv', dbid)
  from gp_segment_configuration
 where role = 'p' and content = -1;
 gp_inject_fault 
-----------------
 Success:
(1 row)

-- The error message from psql can be different, so ignore it
\! psql postgres -c "select 1" 2> /dev/null
-- Wait for the coordinator to be recovered
\! while [ `psql -tc "select 1;" postgres 2>/dev/null | wc -l` != '2' ]; do sleep 1; done;
\c regression
-- All the inject faults have been reset after the coordinator restart
select force_mirrors_to_catch_up();
 force_mirrors_to_catch_up 
---------------------------
 
(1 row)

-- Check that the tables files don't exist on the coordinator and the standby
:check_files
0
0
-- Check that the coordinator recovery didn't remove files of the tables which
-- were created in subtransactions
table t_sub1;
 i 
---
(0 rows)

table t_sub2;
 i 
---
(0 rows)

-- Clean up
drop table t_top, t_sub1, t_sub2;
\unset check_files
-- Test case 2
-- Check that files are left untouched on the coordinator and the standby
-- when the corresponding distributed commit record exists in WAL
select gp_inject_fault('dtm_xlog_distributed_commit', 'segv', dbid)
  from gp_segment_configuration
 where role = 'p' and content = -1;
 gp_inject_fault 
-----------------
 Success:
(1 row)

-- Create tables in a transaction. Get segfault right after the distributed
-- commit record is flushed
\! psql regression -c "begin; select createTables(); commit;"
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
connection to server was lost
-- Wait for the coordinator to be recovered
\! while [ `psql -tc "select 1;" postgres 2>/dev/null | wc -l` != '2' ]; do sleep 1; done;
\c regression
select force_mirrors_to_catch_up();
 force_mirrors_to_catch_up 
---------------------------
 
(1 row)

-- Check that all the tables and its indexes files exist
select '\! ' ||
       string_agg('cd ' || datadir || '&&' || lswc, ';' order by datadir) lswc
  from (
    select 'ls ' || string_agg(pg_relation_filepath(a.unnest), ' ')
                 || ' 2>/dev/null | wc -l' lswc
    from (
      select unnest(array['t_orphaned_h'::regclass,
                          't_orphaned_r'::regclass, 't_orphaned_r_i'::regclass,
                          't_orphaned_c'::regclass, 't_orphaned_c_i'::regclass])
      union all
      select unnest(array[segrelid, blkdirrelid, visimaprelid])
        from pg_catalog.pg_appendonly
        where relid in ('t_orphaned_r'::regclass, 't_orphaned_c'::regclass)
      union all
      select distinct objid from pg_depend where
        classid = 'pg_class'::regclass and deptype = 'a'
        and refobjid in (
          select unnest(array[blkdirrelid,visimaprelid])
            from pg_catalog.pg_appendonly
            where relid in ('t_orphaned_r'::regclass, 't_orphaned_c'::regclass))
    ) a
  ) f,
  (select datadir from gp_segment_configuration where content = -1) d
\gset
:lswc
15
15
-- Check that we can read data from the tables
table t_orphaned_h;
 i 
---
(0 rows)

table t_orphaned_r;
 i 
---
(0 rows)

table t_orphaned_c;
 i 
---
(0 rows)

-- Clean up
drop table t_orphaned_h, t_orphaned_r, t_orphaned_c;
drop function createTables();
-- Test case 3
-- Check that orphaned files are not left on segments when the files are
-- created after checkpoint
create or replace function getTableSegFiles
(t regclass) returns
table (gp_contentid smallint, filepath text) as
$function$
select current_setting('gp_contentid')::smallint, pg_relation_filepath(t)
$function$
language sql
execute on all segments;
-- Get list of the tables file names on each segment
create or replace function createTables() returns text as
$$
declare
  cmd text;
begin
  -- Minimal fillfactor to minimize rows number for creating second main fork file
  create table t_orphaned_h(i int)
  with (fillfactor=10)
  distributed by (i);
  -- Create the .1 file. Separate insert to create FSM. 
  insert into t_orphaned_h select generate_series(1,9000000);

  create table t_orphaned_r
  with (appendonly=true, orientation=row) as
  select i from generate_series(1,100) i
  distributed by (i);

  -- Create the .128 file
  create table t_orphaned_c
  with (appendonly=true, orientation=column) as
  select i as i, i*2 as j from generate_series(1,100) i
  distributed by (i);

  -- Ensure that the mirrors have applied the filesystem changes
  perform force_mirrors_to_catch_up();

  -- The command do not output PGDATA directories to make it possible to run
  -- the test without docker
  select '\! ' ||
         string_agg('cd ' || datadir || '&&' || lswc, ';' order by datadir)
  into cmd
  from (
    select gp_contentid,
           'ls ' || string_agg(f, ' ') || ' 2>/dev/null | wc -l' lswc
    from (
      select gp_contentid, filepath || suf f
        from getTableSegFiles('t_orphaned_h'),
             (values(''), ('.1'), ('_fsm')) v(suf)
      union all
      select gp_contentid, filepath || suf
        from getTableSegFiles('t_orphaned_r'),
             (values('')) v(suf)
      union all
      select gp_contentid, filepath || suf
        from getTableSegFiles('t_orphaned_c'),
             (values(''), ('.128')) v(suf)
    ) a
    group by gp_contentid
  ) f,
  (select content, datadir from gp_segment_configuration where content > -1) d
  where f.gp_contentid = d.content;

  return cmd;
end
$$ language plpgsql;
create or replace function resetInjectFaults(p_contentid int) returns void as
$$
begin
  perform gp_inject_fault('qe_exec_finished', 'reset', dbid),
          gp_inject_fault('checkpoint',       'reset', dbid)
  from gp_segment_configuration
  where role = 'p' and content = p_contentid;
end
$$ language plpgsql;
-- Skip FTS probes
select gp_inject_fault_infinite('fts_probe', 'skip', 1);
 gp_inject_fault_infinite 
--------------------------
 Success:
(1 row)

-- Test case 3.1
-- Segfault on all segments
checkpoint;
-- Skip checkpoints
select gp_inject_fault_infinite('checkpoint', 'skip', dbid)
  from gp_segment_configuration
 where role = 'p' and content > -1;
 gp_inject_fault_infinite 
--------------------------
 Success:
 Success:
 Success:
(3 rows)

-- Create tables in subtransactions
begin;
create table t_top(i int) distributed by (i);
savepoint sp1;
create table t_sub1(i int) distributed by (i);
savepoint sp2;
create table t_sub2(i int) distributed by (i);
commit;
-- Start transaction and create tables in it
begin;
select createTables() check_files
\gset
-- Make sure that all the tables files exist on the segments
:check_files
6
6
6
6
6
6
-- Get segfault on all segments
select gp_inject_fault('qe_exec_finished', 'segv', dbid)
  from gp_segment_configuration
 where role = 'p' and content != -1;
 gp_inject_fault 
-----------------
 Success:
 Success:
 Success:
(3 rows)

select 1 from gp_dist_random('gp_id');
ERROR:  Error on receive from seg0 slice1 127.0.0.1:6002 pid=45456: server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
-- Rollback the transaction to make it possible to run queries after the error
rollback;
select force_mirrors_to_catch_up();
 force_mirrors_to_catch_up 
---------------------------
 
(1 row)

-- Make a checkpoint to remove orphaned files from segments where segfault did
-- not happen
checkpoint;
-- Check that the tables files don't exist on the segments
:check_files
0
0
0
0
0
0
-- Check that the segments recovery didn't remove files of the tables which
-- were created in subtransactions
table t_sub1;
 i 
---
(0 rows)

table t_sub2;
 i 
---
(0 rows)

-- Clean up
drop table t_top, t_sub1, t_sub2;
-- Test case 3.2
-- Segfault on one segment
checkpoint;
-- Skip checkpoints
select gp_inject_fault_infinite('checkpoint', 'skip', dbid)
  from gp_segment_configuration
 where role = 'p' and content > -1;
 gp_inject_fault_infinite 
--------------------------
 Success:
 Success:
 Success:
(3 rows)

-- Create tables in subtransactions
begin;
create table t_top(i int) distributed by (i);
savepoint sp1;
create table t_sub1(i int) distributed by (i);
savepoint sp2;
create table t_sub2(i int) distributed by (i);
commit;
-- Start transaction and create tables in it
begin;
select createTables() check_files
\gset
-- Make sure that all the tables files exist on the segments
:check_files
6
6
6
6
6
6
-- Get segfault on a segment
select gp_inject_fault('qe_exec_finished', 'segv', dbid)
  from gp_segment_configuration
 where role = 'p' and content = 1;
 gp_inject_fault 
-----------------
 Success:
(1 row)

select 1 from gp_dist_random('gp_id');
ERROR:  Error on receive from seg1 slice1 127.0.0.1:6003 pid=64482: server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
-- Rollback the transaction to make it possible to run queries after the error
rollback;
select force_mirrors_to_catch_up();
 force_mirrors_to_catch_up 
---------------------------
 
(1 row)

-- Make a checkpoint to remove orphaned files from segments where segfault did
-- not happen
select gp_inject_fault_infinite('checkpoint', 'reset', dbid)
  from gp_segment_configuration
 where role = 'p' and content > -1;
 gp_inject_fault_infinite 
--------------------------
 Success:
 Success:
 Success:
(3 rows)

checkpoint;
-- Check that the tables files don't exist on the segments
:check_files
0
0
0
0
0
0
-- Check that the segment recovery didn't remove files of the tables which
-- were created in subtransactions
table t_sub1;
 i 
---
(0 rows)

table t_sub2;
 i 
---
(0 rows)

select gp_inject_fault_infinite('fts_probe', 'reset', 1);
 gp_inject_fault_infinite 
--------------------------
 Success:
(1 row)

-- Clean up
\unset check_files
drop table t_top, t_sub1, t_sub2;
drop function createTables();
drop function resetInjectFaults(p_contentid int);
drop function getTableSegFiles(t regclass);
-- start_ignore
-- end_ignore
