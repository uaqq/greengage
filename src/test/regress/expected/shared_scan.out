--
-- Queries that lead to hanging (not dead lock) when we don't handle synchronization properly in shared scan
-- Queries that lead to wrong result when we don't finish executing the subtree below the shared scan being squelched.
--
CREATE SCHEMA shared_scan;
SET search_path = shared_scan;
CREATE TABLE foo (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE bar (c int, d int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE jazz(e int, f int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'e' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO foo values (1, 2);
INSERT INTO bar SELECT i, i from generate_series(1, 100)i;
INSERT INTO jazz VALUES (2, 2), (3, 3);
ANALYZE foo;
ANALYZE bar;
ANALYZE jazz;
SELECT $query$
SELECT * FROM
        (
        WITH cte AS (SELECT * FROM foo)
        SELECT * FROM (SELECT * FROM cte UNION ALL SELECT * FROM cte)
        AS X
        JOIN bar ON b = c
        ) AS XY
        JOIN jazz on c = e AND b = f;
$query$ AS qry \gset
-- We are very particular about this plan shape and data distribution with ORCA:
-- 1. `jazz` has to be the inner table of the outer HASH JOIN, so that on a
-- segment which has zero tuples in `jazz`, the Sequence node that contains the
-- Shared Scan will be squelched on that segment. If `jazz` is not on the inner
-- side, the above mentioned "hang" scenario will not be covered.
-- 2. The Shared Scan producer has to be on a different slice from consumers,
-- and some tuples coming out of the Share Scan producer on one segments are
-- redistributed to a different segment over Motion. If not, the above mentioned
-- "wrong result" scenario will not be covered.
EXPLAIN (COSTS OFF)
:qry ;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ((bar.c = jazz.e) AND (foo.b = jazz.f))
         ->  Hash Join
               Hash Cond: (bar.c = foo.b)
               ->  Seq Scan on bar
               ->  Hash
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: foo.b
                           ->  Append
                                 ->  Seq Scan on foo
                                 ->  Seq Scan on foo foo_1
         ->  Hash
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Hash Key: jazz.f
                     ->  Seq Scan on jazz
 Optimizer: Postgres query optimizer
(17 rows)

SET statement_timeout = '15s';
:qry ;
 a | b | c | d | e | f 
---+---+---+---+---+---
 1 | 2 | 2 | 2 | 2 | 2
 1 | 2 | 2 | 2 | 2 | 2
(2 rows)

RESET statement_timeout;
-- If a Shared Scan is in Subplan, then disuse it and back to normal scan.
SELECT COUNT(*)
FROM (SELECT *,
        (
        WITH cte AS (SELECT * FROM jazz WHERE jazz.e = bar.c)
        SELECT 1 FROM cte c1, cte c2
        )
      FROM bar) as s;
 count 
-------
   100
(1 row)

CREATE TABLE t1 (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t2 (a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- ORCA plan contains a Shared Scan producer with a unsorted Motion below it
EXPLAIN (COSTS OFF)
WITH cte AS (SELECT * FROM t1 WHERE random() < 0.1 LIMIT 10) SELECT a, 1, 1 FROM cte JOIN t2 USING (a);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.a = cte.a)
         ->  Seq Scan on t2
         ->  Hash
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: cte.a
                     ->  Subquery Scan on cte
                           ->  Limit
                                 ->  Gather Motion 3:1  (slice3; segments: 3)
                                       ->  Limit
                                             ->  Seq Scan on t1
                                                   Filter: (random() < '0.1'::double precision)
 Optimizer: Postgres query optimizer
(14 rows)

-- This functions returns one more column than expected.
CREATE OR REPLACE FUNCTION col_mismatch_func1() RETURNS TABLE (field1 int, field2 int)
LANGUAGE 'plpgsql' VOLATILE STRICT AS
$$
DECLARE
   v_qry text;
BEGIN
   v_qry := 'WITH cte AS (SELECT * FROM t1 WHERE random() < 0.1 LIMIT 10) SELECT a, 1 , 1 FROM cte JOIN t2 USING (a)';
  RETURN QUERY EXECUTE v_qry;
END
$$;
-- This should only ERROR and should not SIGSEGV
SELECT col_mismatch_func1();
ERROR:  structure of query does not match function result type
DETAIL:  Number of returned columns (3) does not match expected column count (2).
CONTEXT:  PL/pgSQL function col_mismatch_func1() line 6 at RETURN QUERY
-- ORCA plan contains a Shared Scan producer with a sorted Motion below it
EXPLAIN (COSTS OFF)
WITH cte AS (SELECT * FROM t1 WHERE random() < 0.1 ORDER BY b LIMIT 10) SELECT a, 1, 1 FROM cte JOIN t2 USING (a);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.a = cte.a)
         ->  Seq Scan on t2
         ->  Hash
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: cte.a
                     ->  Subquery Scan on cte
                           ->  Limit
                                 ->  Gather Motion 3:1  (slice3; segments: 3)
                                       Merge Key: t1.b
                                       ->  Limit
                                             ->  Sort
                                                   Sort Key: t1.b
                                                   ->  Seq Scan on t1
                                                         Filter: (random() < '0.1'::double precision)
 Optimizer: Postgres query optimizer
(17 rows)

--- This functions returns one more column than expected.
CREATE OR REPLACE FUNCTION col_mismatch_func2() RETURNS TABLE (field1 int, field2 int)
    LANGUAGE 'plpgsql' VOLATILE STRICT AS
$$
DECLARE
    v_qry text;
BEGIN
    v_qry := 'WITH cte AS (SELECT * FROM t1 WHERE random() < 0.1 ORDER BY b LIMIT 10) SELECT a, 1 , 1 FROM cte JOIN t2 USING (a)';
    RETURN QUERY EXECUTE v_qry;
END
$$;
-- This should only ERROR and should not SIGSEGV
SELECT col_mismatch_func2();
ERROR:  structure of query does not match function result type
DETAIL:  Number of returned columns (3) does not match expected column count (2).
CONTEXT:  PL/pgSQL function col_mismatch_func2() line 6 at RETURN QUERY
-- planner didn't support shared scan under subplan
create table sisc1(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table sisc2(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table sisc3(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
explain (COSTS OFF)
with cte1 as (select * from sisc1),
cte2 as (select * from sisc2),
cte3 as (select * from sisc3)
select * from cte1 where ( EXISTS ( select cte2.a from cte2 left join cte3 on (EXISTS ( select cte1.b from cte2))));
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Subquery Scan on cte1
         Filter: (SubPlan 2)
         ->  Seq Scan on sisc1
         SubPlan 2
           ->  Nested Loop Left Join
                 Join Filter: $1
                 InitPlan 1 (returns $1)  (slice4)
                   ->  Subquery Scan on cte2
                         ->  Materialize
                               ->  Gather Motion 3:1  (slice5; segments: 3)
                                     ->  Seq Scan on sisc2
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on sisc2 sisc2_1
                 ->  Materialize
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on sisc3
 Optimizer: Postgres query optimizer
(20 rows)

with cte1 as (select * from sisc1),
cte2 as (select * from sisc2),
cte3 as (select * from sisc3)
select * from cte1 where ( EXISTS ( select cte2.a from cte2 left join cte3 on (EXISTS ( select cte1.b from cte2))));
 a | b 
---+---
(0 rows)

set gp_cte_sharing = on;
with cte1 as (select * from sisc1),
cte2 as (select * from sisc2),
cte3 as (select * from sisc3)
select * from cte1 where ( EXISTS ( select cte2.a from cte2 left join cte3 on (EXISTS ( select cte1.b from cte2))));
 a | b 
---+---
(0 rows)

reset gp_cte_sharing;
drop table sisc1;
drop table sisc2;
drop table sisc3;
--
-- Check error handling in shared scans
--
-- Helper function to count the number of temporary files in
-- pgsql_tmp.
-- start_ignore
create language plpython3u;
-- end_ignore
create or replace function get_temp_file_num() returns setof int as
$$
import os
fileNum = 0
for root, directories, filenames in os.walk('base/pgsql_tmp'):
  for filename in filenames:
    fileNum += 1
return [fileNum]
$$ language plpython3u execute on all segments;
create table sisc(i int) distributed by (i);
insert into sisc select generate_series(1, 100);
create table sisc2 (i int, j int) distributed by (i);
insert into sisc2 select x, x from generate_series(1, 10) x;
-- Temp file number before running Shared Scan queries
select sum(n) as num_temp_files_before from get_temp_file_num() n
\gset
-- No error, 2 SISC nodes
explain (verbose, costs off)
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i = 1;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Subquery Scan on t1
                           Output: t1.i
                           Filter: (t1.i = 1)
                           ->  Shared Scan (share slice:id 1:0)
                                 Output: share0_ref2.i
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                 ->  Subquery Scan on t2
                                       ->  Shared Scan (share slice:id 2:0)
                                             Output: share0_ref1.i
                                             ->  Seq Scan on shared_scan.sisc
                                                   Output: sisc.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(21 rows)

with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i = 1;
 count 
-------
   100
(1 row)

-- Error, 2 SISC nodes
explain (verbose, costs off)
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i/0 = 1;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Subquery Scan on t1
                           Output: t1.i
                           Filter: ((t1.i / 0) = 1)
                           ->  Shared Scan (share slice:id 1:0)
                                 Output: share0_ref2.i
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                 ->  Subquery Scan on t2
                                       ->  Shared Scan (share slice:id 2:0)
                                             Output: share0_ref1.i
                                             ->  Seq Scan on shared_scan.sisc
                                                   Output: sisc.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(21 rows)

with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i/0 = 1;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=156496)
-- Explicit transaction, 2 SISC nodes
begin;
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i/0 = 1;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=64495)
rollback;
-- Subtransaction, 2 SISC nodes
begin;
savepoint s1;
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i/0 = 1;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=64495)
rollback to s1;
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2 where t1.i/0 = 1;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=64495)
rollback;
-- No error, 3 SISC nodes
explain (verbose, costs off)
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i = 1;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Subquery Scan on t1
                                 Output: t1.i
                                 Filter: (t1.i = 1)
                                 ->  Shared Scan (share slice:id 1:0)
                                       Output: share0_ref3.i
                           ->  Materialize
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Subquery Scan on t2
                                             ->  Shared Scan (share slice:id 2:0)
                                                   Output: share0_ref2.i
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Subquery Scan on t3
                                       ->  Shared Scan (share slice:id 3:0)
                                             Output: share0_ref1.i
                                             ->  Seq Scan on shared_scan.sisc
                                                   Output: sisc.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(27 rows)

with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i = 1;
 count 
-------
 10000
(1 row)

-- Error, 3 SISC nodes
explain (verbose, costs off)
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i/0 = 1;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Subquery Scan on t1
                                 Output: t1.i
                                 Filter: ((t1.i / 0) = 1)
                                 ->  Shared Scan (share slice:id 1:0)
                                       Output: share0_ref3.i
                           ->  Materialize
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Subquery Scan on t2
                                             ->  Shared Scan (share slice:id 2:0)
                                                   Output: share0_ref2.i
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Subquery Scan on t3
                                       ->  Shared Scan (share slice:id 3:0)
                                             Output: share0_ref1.i
                                             ->  Seq Scan on shared_scan.sisc
                                                   Output: sisc.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(27 rows)

with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i/0 = 1;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=156496)
-- No error, 3 SISC nodes with 2 in the same slice
explain (verbose, costs off)
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i = 1 and t1.i = t2.i;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: 1
                           ->  Subquery Scan on t3
                                 ->  Shared Scan (share slice:id 2:0)
                                       Output: share0_ref3.i
                     ->  Materialize
                           ->  Nested Loop
                                 ->  Subquery Scan on t1
                                       Output: t1.i
                                       Filter: (t1.i = 1)
                                       ->  Shared Scan (share slice:id 1:0)
                                             Output: share0_ref2.i
                                 ->  Materialize
                                       Output: t2.i
                                       ->  Subquery Scan on t2
                                             Output: t2.i
                                             Filter: (t2.i = 1)
                                             ->  Shared Scan (share slice:id 1:0)
                                                   Output: share0_ref1.i
                                                   ->  Seq Scan on shared_scan.sisc
                                                         Output: sisc.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(30 rows)

with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i = 1 and t1.i = t2.i;
 count 
-------
   100
(1 row)

-- Error, 3 SISC nodes with 2 in the same slice
explain (verbose, costs off)
with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i/0 = 1 and t1.i = t2.i;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Hash Join
                     Hash Cond: (t1.i = share0_ref1.i)
                     ->  Nested Loop
                           Output: t1.i
                           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                 ->  Subquery Scan on t3
                                       ->  Shared Scan (share slice:id 2:0)
                                             Output: share0_ref3.i
                           ->  Materialize
                                 Output: t1.i
                                 ->  Subquery Scan on t1
                                       Output: t1.i
                                       Filter: ((t1.i / 0) = 1)
                                       ->  Shared Scan (share slice:id 1:0)
                                             Output: share0_ref2.i
                     ->  Hash
                           Output: share0_ref1.i
                           ->  Shared Scan (share slice:id 1:0)
                                 Output: share0_ref1.i
                                 ->  Seq Scan on shared_scan.sisc
                                       Output: sisc.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(29 rows)

with cte as materialized (select i from sisc) select count(*) from cte t1, cte t2, cte t3 where t1.i/0 = 1 and t1.i = t2.i;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=156496)
-- No error, 2 different SISCs
explain (verbose, costs off)
with cte1 as materialized (select i from sisc), cte2 as materialized (select i from sisc) select count(*) from cte1 t1, cte1 t2, cte2 t3, cte2 t4 where t1.i = 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Subquery Scan on t1
                                       Output: t1.i
                                       Filter: (t1.i = 1)
                                       ->  Shared Scan (share slice:id 1:1)
                                             Output: share1_ref2.i
                                 ->  Materialize
                                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                             ->  Subquery Scan on t2
                                                   ->  Shared Scan (share slice:id 2:1)
                                                         Output: share1_ref1.i
                                                         ->  Seq Scan on shared_scan.sisc
                                                               Output: sisc.i
                           ->  Materialize
                                 ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                       ->  Subquery Scan on t3
                                             ->  Shared Scan (share slice:id 3:0)
                                                   Output: share0_ref2.i
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                 ->  Subquery Scan on t4
                                       ->  Shared Scan (share slice:id 4:0)
                                             Output: share0_ref1.i
                                             ->  Seq Scan on shared_scan.sisc sisc_1
                                                   Output: sisc_1.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(35 rows)

with cte1 as materialized (select i from sisc), cte2 as materialized (select i from sisc) select count(*) from cte1 t1, cte1 t2, cte2 t3, cte2 t4 where t1.i = 1;
  count  
---------
 1000000
(1 row)

-- Error, 2 different SISCs
explain (verbose, costs off)
with cte1 as materialized (select i from sisc), cte2 as materialized (select i from sisc) select count(*) from cte1 t1, cte1 t2, cte2 t3, cte2 t4 where t1.i/0 = 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Subquery Scan on t1
                                       Output: t1.i
                                       Filter: ((t1.i / 0) = 1)
                                       ->  Shared Scan (share slice:id 1:1)
                                             Output: share1_ref2.i
                                 ->  Materialize
                                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                             ->  Subquery Scan on t2
                                                   ->  Shared Scan (share slice:id 2:1)
                                                         Output: share1_ref1.i
                                                         ->  Seq Scan on shared_scan.sisc
                                                               Output: sisc.i
                           ->  Materialize
                                 ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                       ->  Subquery Scan on t3
                                             ->  Shared Scan (share slice:id 3:0)
                                                   Output: share0_ref2.i
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                 ->  Subquery Scan on t4
                                       ->  Shared Scan (share slice:id 4:0)
                                             Output: share0_ref1.i
                                             ->  Seq Scan on shared_scan.sisc sisc_1
                                                   Output: sisc_1.i
 Optimizer: Postgres-based planner
 Settings: optimizer = 'off'
(35 rows)

with cte1 as materialized (select i from sisc), cte2 as materialized (select i from sisc) select count(*) from cte1 t1, cte1 t2, cte2 t3, cte2 t4 where t1.i/0 = 1;
ERROR:  division by zero  (seg0 slice1 127.0.1.1:7002 pid=156369)
-- InitPlan tests
-- 1 CTE, 2 references in 2 InitPlans
explain (costs off) with cte as materialized (select i from sisc2)
select (select count(*) from cte) as a, (select count(*) from cte) as b;
                         QUERY PLAN                         
------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)  (slice1)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice2; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 2:0)
                             ->  Seq Scan on sisc2
   InitPlan 2 (returns $1)  (slice3)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 4:0)
 Optimizer: Postgres-based planner
(13 rows)

with cte as materialized (select i from sisc2)
select (select count(*) from cte) as a, (select count(*) from cte) as b;
 a  | b  
----+----
 10 | 10
(1 row)

-- 1 CTE, 4 references in 2 InitPlans and main plan
explain (costs off) with cte as materialized (select i, j from sisc2)
select (select count(*) from cte t1 join cte t2 on t1.j = t2.j) as a,
       (select count(*) from cte t3) as b, i
from cte t4;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1.j = t2.j)
                             ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                   Hash Key: t1.j
                                   ->  Subquery Scan on t1
                                         ->  Shared Scan (share slice:id 4:0)
                             ->  Hash
                                   ->  Redistribute Motion 3:3  (slice5; segments: 3)
                                         Hash Key: t2.j
                                         ->  Subquery Scan on t2
                                               ->  Shared Scan (share slice:id 5:0)
                                                     ->  Seq Scan on sisc2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 7:0)
   ->  Subquery Scan on t4
         ->  Shared Scan (share slice:id 1:0)
 Optimizer: Postgres-based planner
(25 rows)

with cte as materialized (select i, j from sisc2)
select (select count(*) from cte t1 join cte t2 on t1.j = t2.j) as a,
       (select count(*) from cte t3) as b, i
from cte t4;
 a  | b  | i  
----+----+----
 10 | 10 |  1
 10 | 10 |  5
 10 | 10 |  6
 10 | 10 |  9
 10 | 10 | 10
 10 | 10 |  2
 10 | 10 |  3
 10 | 10 |  4
 10 | 10 |  7
 10 | 10 |  8
(10 rows)

-- 1 CTE, 4 references in 3 nested InitPlans and main plan
explain (costs off) with cte as materialized (select i, j from sisc2)
select (select count(*) from cte t1 where (select count(*) from cte t2) > 0) as a,
       (select count(*) from cte t3) as b, i
from cte t4;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Finalize Aggregate
           InitPlan 1 (returns $0)  (slice4)
             ->  Finalize Aggregate
                   ->  Gather Motion 3:1  (slice5; segments: 3)
                         ->  Partial Aggregate
                               ->  Shared Scan (share slice:id 5:0)
                                     ->  Seq Scan on sisc2
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Result
                             One-Time Filter: ($0 > 0)
                             ->  Shared Scan (share slice:id 3:0)
   InitPlan 3 (returns $2)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 7:0)
   ->  Subquery Scan on t4
         ->  Shared Scan (share slice:id 1:0)
 Optimizer: Postgres-based planner
(22 rows)

with cte as materialized (select i, j from sisc2)
select (select count(*) from cte t1 where (select count(*) from cte t2) > 0) as a,
       (select count(*) from cte t3) as b, i
from cte t4;
 a  | b  | i  
----+----+----
 10 | 10 |  2
 10 | 10 |  3
 10 | 10 |  4
 10 | 10 |  7
 10 | 10 |  8
 10 | 10 |  5
 10 | 10 |  6
 10 | 10 |  9
 10 | 10 | 10
 10 | 10 |  1
(10 rows)

-- 2 CTEs, 4 references in 4 InitPlans
explain (costs off)
with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i > 0)
select (select count(j) from cte1),
       (select count(j) from cte2),
       (select count(j) from cte1),
       (select count(j) from cte2);
                         QUERY PLAN                         
------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)  (slice1)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice2; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 2:0)
                             ->  Seq Scan on sisc2
   InitPlan 2 (returns $1)  (slice3)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 4:1)
                             ->  Seq Scan on sisc2 sisc2_1
                                   Filter: (i > 0)
   InitPlan 3 (returns $2)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 6:0)
   InitPlan 4 (returns $3)  (slice7)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice8; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 8:1)
 Optimizer: Postgres-based planner
(25 rows)

with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i > 0)
select (select count(j) from cte1),
       (select count(j) from cte2),
       (select count(j) from cte1),
       (select count(j) from cte2);
 count | count | count | count 
-------+-------+-------+-------
    10 |    10 |    10 |    10
(1 row)

-- 2 CTEs, 4 references in 4 InitPlans with direct dispatch in one
explain (costs off)
with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i = 1)
select (select count(j) from cte1),
       (select count(j) from cte2),
       (select count(j) from cte1),
       (select count(j) from cte2);
                         QUERY PLAN                         
------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)  (slice1)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice2; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 2:0)
                             ->  Seq Scan on sisc2
   InitPlan 2 (returns $1)  (slice3)
     ->  Finalize Aggregate
           ->  Gather Motion 1:1  (slice4; segments: 1)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 4:1)
                             ->  Seq Scan on sisc2 sisc2_1
                                   Filter: (i = 1)
   InitPlan 3 (returns $2)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 6:0)
   InitPlan 4 (returns $3)  (slice7)
     ->  Finalize Aggregate
           ->  Gather Motion 1:1  (slice8; segments: 1)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 8:1)
 Optimizer: Postgres-based planner
(25 rows)

with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i = 1)
select (select count(j) from cte1),
       (select count(j) from cte2),
       (select count(j) from cte1),
       (select count(j) from cte2);
 count | count | count | count 
-------+-------+-------+-------
    10 |     1 |    10 |     1
(1 row)

-- 2 CTEs, 4 references in 4 InitPlans with error in direct dispatch
explain (costs off)
with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i = 1)
select (select count(j) from cte1),
       (select count(j/0) from cte2),
       (select count(j) from cte1),
       (select count(j) from cte2);
                         QUERY PLAN                         
------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)  (slice1)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice2; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 2:0)
                             ->  Seq Scan on sisc2
   InitPlan 2 (returns $1)  (slice3)
     ->  Finalize Aggregate
           ->  Gather Motion 1:1  (slice4; segments: 1)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 4:1)
                             ->  Seq Scan on sisc2 sisc2_1
                                   Filter: (i = 1)
   InitPlan 3 (returns $2)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 6:0)
   InitPlan 4 (returns $3)  (slice7)
     ->  Finalize Aggregate
           ->  Gather Motion 1:1  (slice8; segments: 1)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 8:1)
 Optimizer: Postgres-based planner
(25 rows)

with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i = 1)
select (select count(j) from cte1),
       (select count(j/0) from cte2),
       (select count(j) from cte1),
       (select count(j) from cte2);
ERROR:  division by zero  (seg1 slice4 127.0.1.1:7003 pid=174923)
-- 2 CTEs, 4 references in 4 InitPlans with error in full dispatch
explain (costs off)
with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i = 1)
select (select count(j) from cte1),
       (select count(j) from cte2),
       (select count(j/0) from cte1),
       (select count(j) from cte2);
                         QUERY PLAN                         
------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)  (slice1)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice2; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 2:0)
                             ->  Seq Scan on sisc2
   InitPlan 2 (returns $1)  (slice3)
     ->  Finalize Aggregate
           ->  Gather Motion 1:1  (slice4; segments: 1)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 4:1)
                             ->  Seq Scan on sisc2 sisc2_1
                                   Filter: (i = 1)
   InitPlan 3 (returns $2)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 6:0)
   InitPlan 4 (returns $3)  (slice7)
     ->  Finalize Aggregate
           ->  Gather Motion 1:1  (slice8; segments: 1)
                 ->  Partial Aggregate
                       ->  Shared Scan (share slice:id 8:1)
 Optimizer: Postgres-based planner
(25 rows)

with cte1 as materialized (select i, j from sisc2),
     cte2 as materialized (select i, j from sisc2 where i = 1)
select (select count(j) from cte1),
       (select count(j) from cte2),
       (select count(j/0) from cte1),
       (select count(j) from cte2);
ERROR:  division by zero  (seg1 slice6 127.0.1.1:7003 pid=174923)
-- All temporary files should have been cleaned up, so the number of files shouldn't be more than
-- previously. It could be less if some previously existing file has been cleaned up in the meantime.
select sum(n) as num_temp_files_after from get_temp_file_num() n
\gset
select :num_temp_files_before >= :num_temp_files_after;
 ?column? 
----------
 t
(1 row)

drop table sisc;
drop table sisc2;
drop function get_temp_file_num();
