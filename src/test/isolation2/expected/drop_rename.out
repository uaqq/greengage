-- Test if ALTER RENAME followed by ANALYZE executed concurrently with
-- DROP does not introduce inconsistency between coordinator and segments.
-- DROP should be blocked because of ALTER-ANALYZE.  After being
-- unblocked, DROP should lookup the old name again and fail with
-- relation does not exist error.

1:drop table if exists t1;
DROP TABLE
1:drop table if exists newt1;
DROP TABLE
1:create table t1 (a int, b text) distributed by (a);
CREATE TABLE
1:insert into t1 select i, 'abc '||i from generate_series(1,10)i;
INSERT 0 10
1:begin;
BEGIN
1:alter table t1 rename to newt1;
ALTER TABLE
1:analyze newt1;
ANALYZE
-- this drop should block to acquire AccessExclusive lock on t1's OID.
2&:drop table t1;  <waiting ...>
1:commit;
COMMIT
2<:  <... completed>
ERROR:  table "t1" does not exist
2:select count(*) from newt1;
 count 
-------
 10    
(1 row)

-- DROP is executed concurrently with ALTER RENAME but not ANALYZE.
1:drop table if exists t2;
DROP TABLE
1:drop table if exists newt2;
DROP TABLE
1:create table t2 (a int, b text) distributed by (a);
CREATE TABLE
1:insert into t2 select i, 'pqr '||i from generate_series(1,10)i;
INSERT 0 10
1:begin;
BEGIN
1:alter table t2 rename to newt2;
ALTER TABLE
2&:drop table t2;  <waiting ...>
1:commit;
COMMIT
2<:  <... completed>
ERROR:  table "t2" does not exist
2:select count(*) from newt2;
 count 
-------
 10    
(1 row)

-- The same, but with DROP IF EXISTS. (We used to have a bug, where the DROP
-- command found and drop the relation in the segments, but not in coordinator.)
1:drop table if exists t3;
DROP TABLE
1:create table t3 (a int, b text) distributed by (a);
CREATE TABLE
1:insert into t3 select i, '123 '||i from generate_series(1,10)i;
INSERT 0 10
1:begin;
BEGIN
1:alter table t3 rename to t3_new;
ALTER TABLE
2&:drop table if exists t3;  <waiting ...>
1:commit;
COMMIT
2<:  <... completed>
DROP TABLE
2:select count(*) from t3;
ERROR:  relation "t3" does not exist
LINE 1: select count(*) from t3;
                             ^
2:select relname from pg_class where relname like 't3%';
 relname 
---------
 t3_new  
(1 row)
2:select relname from gp_dist_random('pg_class') where relname like 't3%';
 relname 
---------
 t3_new  
 t3_new  
 t3_new  
(3 rows)

1:drop table if exists t3;
DROP TABLE
1:create table t3 (a int, b text) distributed by (a);
CREATE TABLE
1:insert into t3 select i, '123 '||i from generate_series(1,10)i;
INSERT 0 10
1:begin;
BEGIN
1:drop table t3;
DROP TABLE
2&:drop table if exists t3;  <waiting ...>
3&:drop table t3;  <waiting ...>
1:commit;
COMMIT
3<:  <... completed>
ERROR:  table "t3" does not exist
2<:  <... completed>
DROP TABLE
2:select count(*) from t3;
ERROR:  relation "t3" does not exist
LINE 1: select count(*) from t3;
                             ^

-- Ensure DROP doesn't make inconsistency
-- start_ignore
drop table if exists t4;
DROP TABLE
-- end_ignore
select gp_inject_fault('wait_before_drop_dispatch', 'suspend', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1&:drop table if exists t4;  <waiting ...>
create table t4 (a int, b text) distributed by (a);
CREATE TABLE
select gp_wait_until_triggered_fault('wait_before_drop_dispatch', 1, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)
select gp_inject_fault('wait_before_drop_dispatch', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1<:  <... completed>
DROP TABLE
table t4;
 a | b 
---+---
(0 rows)
drop table t4;
DROP TABLE

-- start_ignore
drop type if exists t5;
DROP TYPE
-- end_ignore
select gp_inject_fault('wait_before_drop_dispatch', 'suspend', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1&:drop type if exists t5;  <waiting ...>
create type t5 as (a int, b text);
CREATE TYPE
select gp_wait_until_triggered_fault('wait_before_drop_dispatch', 1, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)
select gp_inject_fault('wait_before_drop_dispatch', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1<:  <... completed>
DROP TYPE
select null::t5 from gp_dist_random('gp_id');
 t5 
----
    
    
    
(3 rows)
drop type t5;
DROP TYPE

-- start_ignore
drop schema if exists t6;
DROP SCHEMA
-- end_ignore
select gp_inject_fault('wait_before_drop_dispatch', 'suspend', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1&:drop schema if exists t6;  <waiting ...>
create schema t6;
CREATE SCHEMA
select gp_wait_until_triggered_fault('wait_before_drop_dispatch', 1, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)
select gp_inject_fault('wait_before_drop_dispatch', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1<:  <... completed>
DROP SCHEMA
create table t6.t7 (a int, b text) distributed by (a);
CREATE TABLE
drop schema t6 cascade;
DROP SCHEMA
